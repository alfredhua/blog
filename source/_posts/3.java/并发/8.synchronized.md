---
title: synchronized
date: 2022-05-05
keywords: synchronized,java,锁
description: synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。
tags:
  - 并发
categories:
  - 并发
---

# synchronized 
synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。
另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操 作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程， 都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要 相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对 锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的 开销。


## 修饰对象

- 修饰一个方法
- 修饰一个静态的方法
- 修饰一个代码块
- 修饰一个类

## synchronized锁升级

存在4种状态：无锁状态，偏向锁，轻量级锁，重量级锁

- 无锁状态：就是不存在锁定，可以直接执行即可。
- 偏向锁：为了多线程竞争的，减少重量级锁使用操作，系统出现互斥，产生的性能消耗。偏向锁在无竞争的情况下会把整个同步都消除掉。如果锁竞争激烈的话，就会升级为轻量级锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

> 偏向锁获取：当一个线程访问同步块获取锁时，会在对象头(Mark Word)和栈帧中的锁记录里存储偏向锁的线程ID，表示哪个线程获得了偏向锁。
>
> 获取过程：
>
> 1）首先根据锁的标志判断是不是处于偏向锁的状态
>
> 2）如果是偏向锁状态，就通过CAS操作将自己的线程ID写入到MarkWord，如果CAS操作成功，说明当前线程获取到偏向锁，然后就继续执行同步代码块。如果CAS失败，那就是意味着获取锁失败。
>
> 3）如果当前不是偏向锁，那它会去检测MarkWord中存储的线程ID和当前访问的线程的线程ID是否相等，如果相等，就说明当前线程已经是获取偏向锁，然后直接执行同步代码；如果不相等，说明当前偏向锁被其他线程获取，需要**撤销偏向锁**。
>
> 撤销偏向锁：获取偏向锁的线程才会释放偏向锁，撤销偏向锁的过程需要等待一个**全局安全点（也就是等待获取偏向锁的线程都停止字节码执行）**。
>
> 撤销偏向锁的过程：
>
> 1）首先，判断获取偏向锁的线程否为存活状态
>
> 2）如果线程已存亡，那就直接把Mark Word设置为无锁状态
>
> 3）如果线程还存活，当达到全局安全点时，获取的偏向锁的线程会被挂起，然后接着偏向锁升级为轻量级锁，最后唤醒被阻塞在全局安全点的线程继续往下执行同步代码


- 轻量级锁：**不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作**

> 轻量级锁加锁过程
>
> 1）如果这个对象是无锁的，JVM就会在当前线程的栈帧创建用于存储锁记录的空间(LockRecord)，用来将对象头中的Mark Word复制到锁记录中的
>
> 2）然后JVM采用CAS将对象头中的Mark Word替换为指向锁记录的指针
>
> 3）替换成功，说明当前线程获得轻量级锁；替换失败，说明存在其他线程竞争锁。那么当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀**升级为重量级锁**
>
> 自旋，防止线程被挂起，一旦可以获取资源，就直接尝试成功，如果超出阈值，还没有获取锁，那么升级为重量级锁。（自旋锁默认是10次，-XX：PreBlockSpin可以修改）


- 重量级锁：Synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。



# 问题

## 说说自己是怎么使用 synchronized 关键字？

修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。

修饰静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作 用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员( static 表明这是该类的一个静态 资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁)。所以如果一个线程A调用一个实 例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允 许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 

修饰代码块，指定加锁对象：对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方 法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下:synchronized关键字加到非 static 静态 方法上是给对象实例上锁。另外需要注意的是:尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能!

## 讲一下 synchronized 关键字的底层原理？

```
public class SynchronizedTest {
  public static void main(String[] args) {
    synchronized(SynchronizedTest.class){
      System.out.println("pppppp");
    }
  }
}
```


通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息:首先切换到类的对应目录执行 命令生成编译后的 .class 文件，然后执行 javap -c -s -v -l  SynchronizedTest.class。

由此可知：
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同 步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图 获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取 锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设 为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当 前线程就要阻塞等待，直到锁被另外一个线程释放为止。


锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

- 偏向锁：

引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。
但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

- 轻量级锁：

倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。
轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

- 自旋锁和自适应自旋：

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。
一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。

- 锁消除：

锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。

- 锁粗化：

原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

## synchronized关键字和volatile关键字比较

volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关 键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进 行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行 效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。 

- 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 
- volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
-  volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访 问资源的同步性。


